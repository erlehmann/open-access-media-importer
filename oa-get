#!/usr/bin/env python
# -*- coding: utf-8 -*-

from helpers.cli import ArgumentParser
parser = ArgumentParser(choices=[
    'detect-duplicates',
    'download-metadata',
    'download-media',
    'update-mimetypes',
    ])
args = parser.parse_args()

from helpers.cli import init_logging
logging = init_logging(args.verbose)

import progressbar
import magic

from os import path
from sys import argv, stdout
from urllib2 import urlopen, Request, HTTPError

from model import session, set_source, Article, Journal, SupplementaryMaterial

from helpers import config, mediawiki, filename_from_url


def detect_duplicates(source):
    """
    Print DOI, title and label of materials in OAMI database that are
    already uploaded on Mediawiki on standard output, divided by tabs.

    See function mediawiki.is_uploaded for details regarding duplicate
    detection.
    """
    set_source(args.target)
    materials = SupplementaryMaterial.query.filter(
        (SupplementaryMaterial.mimetype_reported=='audio') |
        (SupplementaryMaterial.mimetype_reported=='video')
        ).all()
    if len(materials) == 0:
        logging.warning('No audio or video materials found.')
    for material in materials:
        logging.debug("Checking material %s %s %s" % (
                material.article.doi,
                material.title,
                material.label,
                ))
        if mediawiki.is_uploaded(material):
            stdout.write('%s\t%s\t%s\n' % (
                    material.article.doi,
                    material.title,
                    material.label,
                    ))


def update_mimetypes(source):
    """
    Update internet media type of supplementary materials.

    This function is needed because publishers often misreport media
    types. For Details, see the article “Inconsistent XML as a Barrier
    to Reuse of Open Access Content” from Mietchen, Maloney, Moskopp.
    <http://www.ncbi.nlm.nih.gov/books/NBK159964/#mietchen-mt-problems>
    """
    ms = magic.open(magic.MIME_TYPE)
    ms.load()
    set_source(args.target)
    materials = SupplementaryMaterial.query.filter_by(
        mimetype_reported=None,
        mime_subtype_reported=None
    ).all()
    free_materials = [
        material for material in materials \
            if material.article.license_url in config.free_license_urls
        ]
    materials = free_materials  # Checking MIME types of non-free
                                # supplementary materials costs time.
    logging.info('Checking MIME types …\n')
    try:
        widgets = [
            progressbar.SimpleProgress(), ' ',
            progressbar.Percentage(), ' ',
            progressbar.Bar(), ' ',
            progressbar.ETA()
            ]
        p = progressbar.ProgressBar(
            maxval=len(materials),
            widgets=widgets
            ).start()
    except AssertionError:
        logging.info('No materials found where MIME type has to be checked.')
    for material in materials:
        url = material.url
        request = Request(url, None, {'User-Agent' : 'oa-get/2012-10-26'})
        request.headers['Range'] = 'bytes=%s-%s' % (0, 11)
        # 12 bytes should be enough to detect audio or video resources
        # <http://mimesniff.spec.whatwg.org/#matching-an-audio-or-video-type-pattern>
        p.update(p.currval+1)
        try:
            chunk = urlopen(request).read()
        except HTTPError, e:
            logging.error('When trying to download <%s>, the following error occured: “%s”.' % \
                             (url.encode('utf-8'), str(e)))
            continue
        detected_mimetype = ms.buffer(chunk)
        if 'Document, corrupt' in detected_mimetype:  # partial MS Office document
            request = Request(url, None, {'User-Agent' : 'oa-get/2013-05-24'})
            chunk = urlopen(request, timeout=15).read()
            detected_mimetype = ms.buffer(chunk)
            if detected_mimetype == 'application/msword':
                # MS Office documents are all detected as application/msword, therefore guess based on extension
                # <http://www.mediawiki.org/wiki/Manual_talk:Mime_type_detection#Fix_for_MS_Office_File_Confusion>
                if url.endswith('ppt') or url.endswith('PPT'):
                    detected_mimetype = 'application/vnd.ms-powerpoint'
                elif url.endswith('xls') or url.endswith('XLS'):
                    detected_mimetype = 'application/vnd.ms-excel'
        reported_mimetype = material.mimetype + '/' + material.mime_subtype
        if detected_mimetype == 'application/octet-stream':  # general binary MIME type, useless
            detected_mimetype = reported_mimetype

        def get_mimetype(mimetype):
            try:
                return mimetype.split('/')[0]
            except IndexError:
                pass

        def get_mime_subtype(mimetype):
            try:
                return mimetype.split('/')[1]
            except IndexError:
                pass

        if detected_mimetype != reported_mimetype:
            material.mimetype_reported = material.mimetype
            material.mime_subtype_reported = material.mime_subtype
            material.mimetype = get_mimetype(detected_mimetype) or material.mimetype
            material.mime_subtype = get_mime_subtype(detected_mimetype) or material.mime_subtype
            logging.info(
                'DOI %s, %s, source claimed %s but is %s.\n' % (
                    material.article.doi,
                    material.url,
                    reported_mimetype,
                    detected_mimetype
                )
            )
        else:
            material.mimetype_reported = get_mimetype(reported_mimetype)
            material.mime_subtype_reported = get_mime_subtype(reported_mimetype)
        session.commit()


def download_metadata(source):
    """Download metadata for given OAMI source."""
    source_path = config.get_metadata_raw_source_path(target)
    url = None
    for result in source_module.download_metadata(source_path):
        if result['url'] != url:
            url = result['url']
            logging.info("Downloading “%s”, saving into directory “%s” …" % \
                (url, source_path))
            p = progressbar.ProgressBar(maxval=result['total']).start()
        p.update(result['completed'])


def download_media(source):
    """Download media files for given OAMI source."""
    media_path = config.get_media_raw_source_path(target)
    set_source(args.target)
    materials = SupplementaryMaterial.query.filter_by(
        downloaded=False
    ).all()
    for material in materials:
        license_url = material.article.license_url
        if license_url == '':
            continue
        if not license_url in config.free_license_urls:
            logging.warning('Unknown, possibly non-free license: <%s>\n' %
                license_url)
            continue

        mimetype = mimetype = material.mimetype
        if mimetype not in ['audio', 'video']:
            continue

        if mediawiki.is_uploaded(material):
            logging.info("Skipping <%s>, already exists at %s.\n" % (
                material.url,
                mediawiki.get_wiki_name()
            ))
            material.uploaded=True
            continue

        url = material.url
        try:
            req = Request(url, None, {'User-Agent' : 'oa-get/2012-07-21'})
            remote_file = urlopen(req)
        except HTTPError as e:
            logging.error('When trying to download <%s>, the following error occured: “%s”.' % \
                             (url.encode('utf-8'), str(e)))
            exit(4)
        total = int(remote_file.headers['content-length'])
        completed = 0

        local_filename = path.join(media_path, filename_from_url(url))

        # if local file has same size as remote file, skip download
        try:
            if (path.getsize(local_filename) == total):
                logging.info("Skipping download of <%s>." % url.encode('utf-8'))
                material.downloaded = True
                session.commit()
                continue
        except OSError:  # local file does not exist
            pass

        logging.info("Downloading <%s>, saving as “%s” …" % \
            (url.encode('utf-8'), local_filename.encode('utf-8')))
        p = progressbar.ProgressBar(maxval=total).start()

        with open(local_filename,'wb') as local_file:
            while True:
                chunk = remote_file.read(1024000)  # chunk size 1024KB
                if chunk != '':
                    local_file.write(chunk)
                    completed += len(chunk)
                    p.update(completed)
                else:
                    break

                material.downloaded = True
                session.commit()


if args.action == 'detect-duplicates':
    detect_duplicates(args.target)

if args.action == 'download-metadata':
    download_metadata(args.target)

if args.action == 'download-media':
    download_media(args.target)

if args.action == 'update-mimetypes':
    update_mimetypes(args.target)
